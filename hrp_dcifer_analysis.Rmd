---
title: "Dcifer heatmap & network plot"
author: "William Louie"
date: "`r Sys.Date()`"
output: html_document
---

**Libraries**
```{r load libraries, warning=FALSE, message=FALSE}

library(moire)
library(dcifer)
library(dplyr)
library(magrittr)
library(ggplot2)
library(igraph) #v0.5.1 supports "add_shape" function
library(ggnewscale)
library(descriptr)
library(readr)
library(plotly)
library(stringr)
library(ggpubr)

```


Import dcifer results: "dcifer_results.rds"

```{r dcifer_heatmap, exercise=TRUE, echo=F}

# Import dcifer results (.rds)
dres <- readr::read_rds("/Users/williamlouie/Dropbox/My Mac (Williams-MacBook-Pro.local)/Downloads/Ethiopia/hrp_moire/dcifer_results.rds") 

# relatedness
dmat <- dres[, , "estimate"]
dmat[upper.tri(dmat)] <- t(dmat)[upper.tri(t(dmat))]

# p-value groups
dres0 <- dres[, , "p_value"]
dres_low <- -log10(dres0)

dres_low[dres_low > -log10(0.001)] <- "P < 0.001"
dres_low[dres_low <= -log10(0.01) & dres_low > -log10(0.05)] <- "P < 0.05"
dres_low[dres_low <= -log10(0.001) & dres_low > -log10(0.01)] <- "P < 0.01"
dres_low[dres_low <= -log10(0.05)] <- "Not Sig"
dres_low[upper.tri(dres_low)] <- t(dres_low)[upper.tri(dres_low)]


matrix_to_longformat <- function(mat) {
  as.data.frame(mat) |>
    tibble::rownames_to_column("sample.x") |>
    tidyr::pivot_longer(-sample.x, names_to = "sample.y", values_to = "value")
}

to_plot1 <- matrix_to_longformat(dmat)

# dmat, Relatedness    
hc <- hclust(as.dist(1 - dmat))
order = hc$order
clustered_levels = colnames(dmat)[order]

# dres_low, p-value    
to_plot1 <- to_plot1 |>
  dplyr::mutate(sample.x = forcats::fct_relevel(sample.x, clustered_levels),
                sample.y = forcats::fct_relevel(sample.y, clustered_levels))

to_plot2 <- matrix_to_longformat(dres_low)
to_plot2 <- to_plot2 |>
  dplyr::mutate(sample.x = forcats::fct_relevel(sample.x, clustered_levels),
                sample.y = forcats::fct_relevel(sample.y, clustered_levels))

colours_upper <- colorRampPalette(c("#FFFFFF", "#1520A6"))(100)
colours_lower <- c("P < 0.001" = "#C70039", "P < 0.01" = "#FF5733", "P < 0.05" = "#FFC300", "Not Sig" = "white")


# Combined Heatmap 
ggplot(to_plot1, aes(x = sample.x, y = sample.y)) +
  geom_raster(data = subset(to_plot1, as.numeric(sample.x) > as.numeric(sample.y)), aes(fill = value)) +
  scale_fill_gradientn(colors = colours_upper, name = "Relatedness") +
  theme(axis.text.x = element_text(angle = 90, hjust = 0)) +
  theme(axis.text.y = element_text(hjust = 0)) +
  new_scale_fill() + # Add the p-value layer
  geom_tile(data = subset(to_plot2, as.numeric(sample.x) < as.numeric(sample.y)),
            aes(fill = value)) +
  scale_fill_manual(values = colours_lower, name = "Significance", breaks = c("P < 0.001", "P < 0.01", "P < 0.05")) +
  scale_x_discrete(limits = clustered_levels) +
  scale_y_discrete(limits = clustered_levels)


```

Dcfer heatmap by variables
## Look at Highlands, Lowlands - RP, Lowlands SMW

```{r dcifer heatmap_by_var, exercise=TRUE, echo=F}

metadata_full <- read.csv("/Users/williamlouie/Dropbox/My Mac (Williams-MacBook-Pro.local)/Downloads/Ethiopia/hrp_moire/HRP_metadata.csv")

hrp_db <- read.csv("/Users/williamlouie/Dropbox/My Mac (Williams-MacBook-Pro.local)/Downloads/Ethiopia/hrp_moire/HRP_sampleDB_2024-08-16.csv") %>%
  mutate(QR_code = as.integer(word(StudySubject, 2, sep = "H")))

metadata <- metadata_full %>%
  inner_join(hrp_db, by = "QR_code") %>%
  select(StudySubject, Population)
HL <- metadata %>%
  filter(Population == "HL - General population") %>%
  pull(StudySubject)
LLs <- metadata %>%
  filter(Population == "LL - Seasonal migrant worker") %>%
  pull(StudySubject)
LLr <- metadata %>%
  filter(Population == "LL - Resident population") %>%
  pull(StudySubject)

## Classify as within or between
to_plot_within1 <- to_plot1 %>%
  mutate(StudySubject = sample.x) %>%
  select(-sample.x) %>% 
  inner_join(metadata, by = "StudySubject") %>%
  rename(sample.x = StudySubject) %>%
  rename(Population.X = Population) %>%
  mutate(StudySubject = sample.y) %>%
  inner_join(metadata, by = "StudySubject") %>%
  rename(Population.Y = Population) %>%
  select(-StudySubject) %>% 
  mutate(group = case_when(
    Population.X == Population.Y ~ "within",
    Population.X != Population.Y ~ "between")) %>%
  filter(group == "within")

## Classify as within or between
to_plot_within2 <- to_plot2 %>%
  mutate(StudySubject = sample.x) %>%
  select(-sample.x) %>% 
  inner_join(metadata, by = "StudySubject") %>%
  rename(sample.x = StudySubject) %>%
  rename(Population.X = Population) %>%
  mutate(StudySubject = sample.y) %>%
  inner_join(metadata, by = "StudySubject") %>%
  rename(Population.Y = Population) %>%
  select(-StudySubject) %>% 
  mutate(group = case_when(
    Population.X == Population.Y ~ "within",
    Population.X != Population.Y ~ "between")) %>%
  filter(group == "within")

colours_upper <- colorRampPalette(c("#FFFFFF", "#1520A6"))(100)
colours_lower <- c("P < 0.001" = "#C70039", "P < 0.01" = "#FF5733", "P < 0.05" = "#FFC300", "Not Sig" = "white")

# dres_low, p-value    
to_plot_within1 <- to_plot_within1 |>
  dplyr::mutate(sample.x = forcats::fct_relevel(as.character(sample.x), clustered_levels),
                sample.y = forcats::fct_relevel(as.character(sample.y), clustered_levels))
to_plot_within2 <- to_plot_within2 |>
  dplyr::mutate(sample.x = forcats::fct_relevel(as.character(sample.x), clustered_levels),
                sample.y = forcats::fct_relevel(as.character(sample.y), clustered_levels))

# Highland only
to_plot_within1_hl <- to_plot_within1 %>%
  filter(grepl(pattern = "HL", Population.X))
to_plot_within2_hl <- to_plot_within2 %>%
  filter(grepl(pattern = "HL", Population.X))
cluster_hl <- factor(HL, levels = clustered_levels)
cluster_HL <- as.character(sort(cluster_hl))

# Combined Heatmap 
within_hl <- ggplot(to_plot_within1_hl, aes(x = sample.x, y = sample.y)) +
  geom_tile(data = subset(to_plot_within1_hl, as.numeric(sample.x) > as.numeric(sample.y)), aes(fill = value)) +
  scale_fill_gradientn(colors = colours_upper, name = "Relatedness") +
  theme(axis.text.x = element_blank()) +
  theme(axis.text.y = element_blank()) +
  new_scale_fill() + # Add the p-value layer
  geom_tile(data = subset(to_plot_within2_hl, as.numeric(sample.x) < as.numeric(sample.y)),
            aes(fill = value)) +
  scale_fill_manual(values = colours_lower, name = "Significance", breaks = c("P < 0.001", "P < 0.01", "P < 0.05")) +
  scale_x_discrete(limits = cluster_HL) +
  scale_y_discrete(limits = cluster_HL) +
  facet_wrap(~Population.X, scales = "free")
within_hl


# Lowland migrant population only
to_plot_within1_lls <- to_plot_within1 %>%
  filter(grepl(pattern = "LL - Seasonal", Population.X))
to_plot_within2_lls <- to_plot_within2 %>%
  filter(grepl(pattern = "LL - Seasonal", Population.X))
cluster_lls <- factor(LLs, levels = clustered_levels)
cluster_LLs <- as.character(sort(cluster_lls))

# Combined Heatmap 
within_lls <- ggplot(to_plot_within1_lls, aes(x = sample.x, y = sample.y)) +
  geom_tile(data = subset(to_plot_within1_lls, as.numeric(sample.x) > as.numeric(sample.y)), aes(fill = value)) +
  scale_fill_gradientn(colors = colours_upper, name = "Relatedness") +
  theme(axis.text.x = element_blank()) +
  theme(axis.text.y = element_blank()) +
  new_scale_fill() + # Add the p-value layer
  geom_tile(data = subset(to_plot_within2_lls, as.numeric(sample.x) < as.numeric(sample.y)),
            aes(fill = value)) +
  scale_fill_manual(values = colours_lower, name = "Significance", breaks = c("P < 0.001", "P < 0.01", "P < 0.05")) +
  scale_x_discrete(limits = cluster_LLs) +
  scale_y_discrete(limits = cluster_LLs) +
  facet_wrap(~Population.X, scales = "free")
within_lls


# Lowland migrant population only
to_plot_within1_llr <- to_plot_within1 %>%
  filter(grepl(pattern = "LL - Resident", Population.X))
to_plot_within2_llr <- to_plot_within2 %>%
  filter(grepl(pattern = "LL - Resident", Population.X))
cluster_llr <- factor(LLr, levels = clustered_levels)
cluster_LLr <- as.character(sort(cluster_llr))

# Combined Heatmap 
within_llr <- ggplot(to_plot_within1_llr, aes(x = sample.x, y = sample.y)) +
  geom_tile(data = subset(to_plot_within1_llr, as.numeric(sample.x) > as.numeric(sample.y)), aes(fill = value)) +
  scale_fill_gradientn(colors = colours_upper, name = "Relatedness") +
  theme(axis.text.x = element_blank()) +
  theme(axis.text.y = element_blank()) +
  new_scale_fill() + # Add the p-value layer
  geom_tile(data = subset(to_plot_within2_llr, as.numeric(sample.x) < as.numeric(sample.y)),
            aes(fill = value)) +
  scale_fill_manual(values = colours_lower, name = "Significance", breaks = c("P < 0.001", "P < 0.01", "P < 0.05")) +
  scale_x_discrete(limits = cluster_LLr) +
  scale_y_discrete(limits = cluster_LLr) +
  facet_wrap(~Population.X, scales = "free")
within_llr

# Combine plots
within_comb <- ggarrange(within_llr, within_lls, within_hl, common.legend = TRUE)
within_comb
ggsave("HRP_dcifer_within.pdf", plot = within_comb, width = 10, height = 10)

```

**Dcifer cluster network plot**

```{r cluster network plot, exercise=TRUE, echo=F}

# Make dcifer_list for cluster plot
dres0 <- dres[, , "p_value"]
dres0[upper.tri(dres0, diag = F)] <- 0
dres1 <- dres0 + t(dres0) 

isSymmetric.matrix(dres1) #TRUE
isSymmetric.matrix(dmat) #TRUE

dcifer_list = list(id=colnames(dmat), relatedness=dmat, pvalue=dres1)

# Relatedness distribution
hist_relatedness <- hist(dmat[upper.tri(dmat, diag = F)], xlab = "Estimated pairwise relatedness", 
     main = "Histogram of Dcifer estimated pairwise relatedness", breaks = 50) 
r_value_df <- data.frame(r_value = dmat[upper.tri(dmat, diag = F)])
r_value_freq_table <- ds_freq_table(r_value_df, r_value, 10)
print(r_value_freq_table) 

# P-value distribution
hist_p_value <- hist(dres1[upper.tri(dmat, diag = F)], xlab = "Estimated p-value", 
     main = "Histogram of Dcifer estimated significance of pairwise relatedness", breaks = 50) #p-value
p_value_df <- data.frame(p_value = dres1[upper.tri(dmat, diag = F)])
p_value_freq_table <- ds_freq_table(p_value_df, p_value, 10)
print(p_value_freq_table)

# Significant relatedness distribution
isig <- which(dres <= 0.05, arr.ind = TRUE)[, 2:1] 
hist(dmat[isig], breaks = 50,  xlab = "Significant relatedness", 
     main = "Histogram of significant relatedness")
sig_r_df <- data.frame(sig_r = dmat[isig])
sig_r_freq_table <- ds_freq_table(sig_r_df, sig_r, 10)
print(sig_r_freq_table)

# Cluster plot
plotClusters <- function(dcifer_list, level=0.5, alpha=0.05, vSize=5, vColor='white', thick = 2, vFontSize=.5, labelOffset=1, showLabel = T){
  edges <- NULL
  wgts <- NULL
  isolates <- dcifer_list$id
  for (i in seq(length(dcifer_list$id)-1)){
    for (j in seq(i+1, length(dcifer_list$id))){
      if (dcifer_list$relatedness[i,j]>=level){
        if(dcifer_list$pvalue[i,j]<= alpha){
        edges <- c(edges, dcifer_list$id[[i]], dcifer_list$id[[j]])
        wgts <- c(wgts, thick*dcifer_list$relatedness[i,j])
        isolates <- isolates[isolates != dcifer_list$id[[i]]]
        isolates <- isolates[isolates != dcifer_list$id[[j]]]
        }
      }
    }
  }
  gtitle <- paste0('Cluster plot for relatedness >= ',level)
  cgraph <- igraph::graph(edges=edges, isolates=isolates, directed=F)
  
  igraph::E(cgraph)$weight <- wgts
  
  #showLabel
  if(showLabel == TRUE){
    plot(cgraph, edge.width=igraph::E(cgraph)$weight, vertex.size=vSize, vertex.color=vColor, main=gtitle, frame=TRUE, vertex.label.cex=vFontSize, vertex.label.dist=labelOffset)
  }

  if(showLabel == FALSE){
    plot(cgraph, edge.width=igraph::E(cgraph)$weight, vertex.size=vSize, vertex.color=vColor, main=gtitle, frame=TRUE, vertex.label.cex=vFontSize, vertex.label.dist=labelOffset, vertex.label = NA)
  }
  
   # Create a legend for line thickness
  legend("bottomright",
         legend = c(0.9, 0.6, 0.3),
         title = "R",
         lty = 1,
         lwd = c(thick*0.9, thick*0.6, thick*0.3), # Adjust line thickness here
         col = "darkgray")  

  return(cgraph)  
}

cluster_plot <- plotClusters(dcifer_list, level=0.9, alpha=0.05, vSize=2, vColor='white', thick=2.5, vFontSize=.5, labelOffset=.5, showLabel = F) # level = relatedness cutoff, alpha = p-value cutoff

cluster_plot <- plotClusters(dcifer_list, level=0.75, alpha=0.05, vSize=2, vColor='white', thick=2.5, vFontSize=.5, labelOffset=.5, showLabel = F) 

cluster_plot <- plotClusters(dcifer_list, level=0.5, alpha=0.05, vSize=2, vColor='white', thick=2.5, vFontSize=.5, labelOffset=.5, showLabel = F) 

```


**Cluster group feature plot**
```{r cluster_by_var, exercise=TRUE, echo=F}

epi_data <- metadata_full %>%
  inner_join(hrp_db, by = "QR_code") %>%
  select(StudySubject, Population, High_Low)

sample_list <- dcifer_list$id

epi <- epi_data %>%
  filter(StudySubject %in% sample_list) %>%
  rename("id" = StudySubject) %>%
  mutate(color = case_when(
    Population == "LL - Seasonal migrant worker" ~ "red",
    Population == "LL - Resident population" ~ "darkgreen",
    Population == "HL - General population" ~ "blue")) %>%
  mutate(shape = case_when(
    High_Low == "Lowland" ~ "square",
    High_Low == "Highland" ~ "circle"))
write_csv(epi, "epi_data.csv")

# Input grouping files
setGroupsFromFile <- function(dcifer_list, filename)
{
  thisData <- read.csv(filename)
  group_ids <- as.vector(thisData[,1])
  group <- as.vector(thisData[,2])
  dcifer_list$group <- group
  if(!all(group_ids==dcifer_list$id)){
    print("Warning: IDs in group file don't match those on the model.")
    print(group_ids)
  }
  return(dcifer_list)
}

# Set group labels
setGroupLabels <- function(dcifer_list, filename){
  thisData <- read.csv(filename)
  labels <- as.vector(thisData[,2])
  dcifer_list$group_label <- labels
  return(dcifer_list)
}

# Set group colors
setGroupColours <- function(dcifer_list, filename){
  thisData <- read.csv(filename)
  colours <- as.vector(thisData[,4])
  dcifer_list$group_color <- colours
  return(dcifer_list)
}

GroupColour <- function(dcifer_list, group_label){
  index <- match(group_label, dcifer_list$group_label)
  if (is.na(index)) return ("white")
  return(dcifer_list$group_color[[index]])
}

# Set time labels
### Time = Highland or Lowland
setTimeLabels <- function(dcifer_list, filename){
  thisData <- read.csv(filename)
  time_labels <- as.vector(thisData[,3])
  dcifer_list$time_label <- time_labels
  return(dcifer_list)
}

# Set time shapes
setTimeShapes <- function(dcifer_list, filename){
  thisData <- read.csv(filename)
  shapes <- as.vector(thisData[,5])
  dcifer_list$time_shape <- shapes
  return(dcifer_list)
}

TimeShapes <- function(dcifer_list, time_label){
  index <- match(time_label, dcifer_list$time_label)
  if (is.na(index)) return ("none")
  return(dcifer_list$time_shape[[index]])
}


plotClusterGroup <- function(dcifer_list, level=0.5, alpha=0.05, vSize=2, thick = 2, vFontSize=.5, 
                             labelOffset=1, legend_x=2, legend_y=2, group_name = 'Population', showLabel = F){
  edges <- NULL
  wgts <- NULL
  vcolours <- NULL
  isolates <- dcifer_list$id
  for (i in seq(length(dcifer_list$id)-1)){
    for (j in seq(i+1, length(dcifer_list$id))){
      if (dcifer_list$relatedness[i,j]>=level){
        if(dcifer_list$pvalue[i,j]<= alpha){
          edges <- c(edges, dcifer_list$id[[i]], dcifer_list$id[[j]])
          wgts <- c(wgts, thick*dcifer_list$relatedness[i,j])
          isolates <- isolates[isolates != dcifer_list$id[[i]]]
          isolates <- isolates[isolates != dcifer_list$id[[j]]]
        }
      }
    }
  }
  
  gtitle <- paste0('Cluster plot for relatedness >= ',level, ' by ', group_name)
  cgraph <- igraph::graph(edges=edges, isolates=isolates, directed=F)
  
  # Assign vertex colors
  for (c in 1:length(V(cgraph))){
    #since the names in the first column are only a part of all the nodes check if it belongs to that sublist
    if(V(cgraph)$name[c] %in% dcifer_list$id) {
      #then find the first occurrence of that name in the list and get its related color
      #assign it to that node
      V(cgraph)$color[c] <- as.character(dcifer_list$group_color[which(dcifer_list$id==V(cgraph)$name[c])[1]])
    }
    #otherwise the node will be white 
    else {
      V(cgraph)$color[c] <- "white"
    }
  }
  
  igraph::E(cgraph)$weight <- wgts
  
   # Assign vertex shapes
  for (c in 1:length(V(cgraph))){
    #since the names in the first column are only a part of all the nodes check if it belongs to that sublist
    if(V(cgraph)$name[c] %in% dcifer_list$id) {
      #then find the first occurrence of that name in the list and get its related shape
      #assign it to that node
      V(cgraph)$shape[c] <- as.character(dcifer_list$time_shape[which(dcifer_list$id==V(cgraph)$name[c])[1]])
    }
    #otherwise the node will be none
    else {
      V(cgraph)$shape[c] <- "none"
    }
  }

   #showLabel
  if(showLabel == TRUE){
    plot(cgraph, edge.width=igraph::E(cgraph)$weight, vertex.size=vSize, vertex.color=igraph::V(cgraph)$color, 
       vertex.shape=igraph::V(cgraph)$shape, main=gtitle, frame=TRUE, vertex.label.cex=vFontSize, vertex.label.dist=labelOffset)
  }

  if(showLabel == FALSE){
    plot(cgraph, edge.width=igraph::E(cgraph)$weight, vertex.size=vSize, vertex.color=igraph::V(cgraph)$color, 
       vertex.shape=igraph::V(cgraph)$shape, main=gtitle, frame=TRUE, vertex.label.cex=vFontSize, vertex.label.dist=labelOffset,
       vertex.label = NA)
  }
  
  # Create a legend for line thickness
  legend("topright",
         legend = c(0.9, 0.6, 0.3),
         title = "R",
         lty = 1,
         lwd = c(thick*0.9, thick*0.6, thick*0.3), # Adjust line thickness here
         col = "darkgray")
    # Create a legend for groups
  legend("bottomright",
         legend = c("HL: resident", "LL: migrant worker", "LL: resident"),
         title = "Population",
         col = c("blue", "red", "darkgreen"),
         pch = 1)

  coord <- par("usr")
  graphics::legend("bottomright",
                   x=coord[legend_x], y=coord[legend_y],
                   title=group_name,
                   legend=unique(dcifer_list$group_label),
                   fill=unique(dcifer_list$group_color))
  return(cgraph)
}


# Add igraph vertex shapes - triangle and star
mytriangle <- function(coords, v = NULL, params) {
  vertex.color <- params("vertex", "color")
  if (length(vertex.color) != 1 && !is.null(v)) {
    vertex.color <- vertex.color[v]
  }
  vertex.size <- 1 / 200 * params("vertex", "size")
  if (length(vertex.size) != 1 && !is.null(v)) {
    vertex.size <- vertex.size[v]
  }
  
  symbols(
    x = coords[, 1], y = coords[, 2], bg = vertex.color,
    stars = cbind(vertex.size, vertex.size, vertex.size),
    add = TRUE, inches = FALSE
  )
}
add_shape("triangle",
          clip = shapes("circle")$clip,
          plot = mytriangle
)

mystar <- function(coords, v = NULL, params) {
  vertex.color <- params("vertex", "color")
  if (length(vertex.color) != 1 && !is.null(v)) {
    vertex.color <- vertex.color[v]
  }
  vertex.size <- 1 / 200 * params("vertex", "size")
  if (length(vertex.size) != 1 && !is.null(v)) {
    vertex.size <- vertex.size[v]
  }
  norays <- params("vertex", "norays")
  if (length(norays) != 1 && !is.null(v)) {
    norays <- norays[v]
  }
  
  mapply(coords[, 1], coords[, 2], vertex.color, vertex.size, norays,
         FUN = function(x, y, bg, size, nor) {
           symbols(
             x = x, y = y, bg = bg,
             stars = matrix(c(size, size / 2), nrow = 1, ncol = nor * 2),
             add = TRUE, inches = FALSE
           )
         }
  )
}
add_shape("star",
          clip = shape_noclip,
          plot = mystar, parameters = list(vertex.norays = 5)
)


# Run with group-assigned files
filename <- '/Users/williamlouie/Dropbox/My Mac (Williams-MacBook-Pro.local)/Downloads/Ethiopia/hrp_moire/epi_data.csv'
dcifer_list <- setGroupsFromFile(dcifer_list, filename)
dcifer_list <- setGroupColours(dcifer_list, filename)
dcifer_list <- setGroupLabels(dcifer_list, filename)
dcifer_list <- setTimeLabels(dcifer_list, filename)
dcifer_list <- setTimeShapes(dcifer_list, filename)

plotClusterGroup(dcifer_list, level=0.9, alpha=0.05, vSize=4, thick = 2.5, labelOffset=1,legend_x=2, legend_y=2, group_name='Population', showLabel = F) 


plotClusterGroup(dcifer_list, level=0.75, alpha=0.05, vSize=4, thick = 2.5, labelOffset=1,legend_x=2, legend_y=2, group_name='Population', showLabel = F) 


plotClusterGroup(dcifer_list, level=0.5, alpha=0.05, vSize=4, thick = 2.5, labelOffset=1,legend_x=2, legend_y=2, group_name='Population', showLabel = F) 


# ggarrange(cluster0.9, cluster0.75, cluster0.5, 
#           ncol = 2, nrow = 2,
#           common.legend = TRUE)


```


# Extract clustered sampleIDs
```{r extract clusters, exercise=TRUE, echo=F}

extract_clusters <- function(cluster_plot) {
  
g <- igraph::max_cliques(cluster_plot) #This cluster_list would link to the level you set for cluster_plot (in this case would report samples with R>=0.9)
cluster_list <- lapply(g, names)

result_list <- list()
for (sublist in cluster_list) {
  if (length(sublist) > 1) {
    result_list <- append(result_list, list(sublist))
  }
}

### Merge sublists with overlapping elements
merge_overlap <- function(lst) {
  # Create an empty list to store merged sublists
  merged_list <- list()
  
  for (sublist in lst) {
    # Check if the sublist has any overlapping elements with existing merged sublists
    overlapping_index <- sapply(merged_list, function(merged_sublist) any(sublist %in% merged_sublist))
    
    if (any(overlapping_index)) {
      # Merge the sublist with overlapping sublists
      merged_sublist <- unique(unlist(c(sublist, merged_list[overlapping_index])))
      
      # Remove the overlapping sublists
      merged_list <- merged_list[!overlapping_index]
      
      # Add the merged sublist to the merged_list
      merged_list <- append(merged_list, list(merged_sublist))
    } else {
      # Add the original sublist to the merged_list
      merged_list <- append(merged_list, list(sublist))
    }
  }
  
  return(merged_list)
}

# Merge sublists with overlapping elements
merged_result_list <- merge_overlap(result_list)

### Turn the list into dataframe
# Initialize empty vectors to store values and sublist numbers
all_values <- c()
sublist_number <- c()

# Iterate through the merged_result_list
for (i in seq_along(merged_result_list)) {
  values <- merged_result_list[[i]]
  
  # Extend the all_values vector with the values from the current sublist
  all_values <- c(all_values, values)
  
  # Extend the sublist_number vector with the corresponding sublist number for each value
  sublist_number <- c(sublist_number, rep(i, length(values)))
}

# Create a dataframe from the vectors
cluster_df <- data.frame(Values = all_values, SublistNumber = sublist_number)
cluster_df %<>% rename(sampleID = Values, cluster = SublistNumber)
cluster_df %<>% arrange(cluster, sampleID)

return(cluster_df)

}

clusterID <- extract_clusters(cluster_plot)
write_csv(clusterID, "cluster_id.csv")

```